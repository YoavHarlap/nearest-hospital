<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>×œ×™××•×“ ××™×œ×™× ×‘×× ×’×œ×™×ª (Quizlet-style)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Heebo", sans-serif; }
    body { margin: 0; background: #0b0c10; color: #e9eef5; }
    header { padding: 16px 18px; border-bottom: 1px solid rgba(255,255,255,.08); background:#0f1118; position: sticky; top: 0; z-index: 10; }
    header h1 { margin: 0; font-size: 16px; font-weight: 700; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 16px; display: grid; gap: 14px; }
    .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .btn {
      appearance: none; border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06); color: #e9eef5;
      padding: 10px 12px; border-radius: 12px; cursor: pointer;
      font-weight: 650; font-size: 14px;
    }
    .btn:hover { background: rgba(255,255,255,.10); }
    .btn.primary { background: rgba(0, 170, 255, .18); border-color: rgba(0, 170, 255, .35); }
    .btn.danger { background: rgba(255, 70, 70, .16); border-color: rgba(255, 70, 70, .35); }
    .btn.ghost { background: transparent; }
    .pill {
      padding: 6px 10px; border-radius: 999px; font-size: 12px;
      border: 1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06);
    }

    .card {
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 8px 30px rgba(0,0,0,.25);
    }

    .quizCard { display: grid; gap: 14px; }
    .wordBox {
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      padding: 20px;
      display: grid; gap: 10px;
    }
    .en { font-size: 34px; font-weight: 800; letter-spacing: .2px; direction: ltr; text-align: left; }
    .he { font-size: 18px; opacity: .95; display: none; }
    .he.show { display: block; }

    .muted { opacity: .75; font-size: 13px; }
    .split { display: grid; grid-template-columns: 1.1fr .9fr; gap: 14px; }
    @media (max-width: 900px){ .split { grid-template-columns: 1fr; } }

    textarea {
      width: 100%; min-height: 160px;
      border-radius: 14px; padding: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25); color: #e9eef5;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      direction: ltr; text-align: left;
    }
    .tableWrap { overflow: auto; border-radius: 14px; border: 1px solid rgba(255,255,255,.10); }
    table { width: 100%; border-collapse: collapse; min-width: 520px; }
    th, td { padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,.08); }
    th { text-align: right; font-size: 12px; opacity: .8; background: rgba(255,255,255,.04); position: sticky; top: 0; }
    td.enCell { direction: ltr; text-align: left; font-weight: 650; }
    td.heCell { direction: rtl; text-align: right; }
    tr:hover td { background: rgba(255,255,255,.03); }
    .tag { font-size: 12px; padding: 3px 8px; border-radius: 999px; border: 1px solid rgba(255,255,255,.14); }
    .tag.bad { border-color: rgba(255, 70, 70, .35); background: rgba(255, 70, 70, .14); }
    .tag.ok { border-color: rgba(0, 200, 120, .35); background: rgba(0, 200, 120, .14); }

    .hidden { display: none !important; }
  </style>
</head>

<body>
<header>
  <h1>×œ×™××•×“ ××™×œ×™× ×‘×× ×’×œ×™×ª â€” ××¦×‘ ×§×•×•×™×–×œ×˜ (×©××™×¨×” ××•×˜×•××˜×™×ª ×‘Ö¾localStorage)</h1>
</header>

<div class="wrap">

  <div class="row">
    <button class="btn primary" id="modeAllBtn">×ª×¨×’×•×œ ×›×œ ×”××™×œ×™× (×¨× ×“×•××œ×™)</button>
    <button class="btn" id="modeUnknownBtn">×ª×¨×’×•×œ ×¨×§ â€œ×œ× ×™×“×¢×ª×™â€</button>
    <button class="btn ghost" id="viewAllBtn">×¨×©×™××ª ×›×œ ×”××™×œ×™×</button>
    <button class="btn ghost" id="viewUnknownBtn">×¨×©×™××ª â€œ×œ× ×™×“×¢×ª×™â€</button>
    <span class="pill" id="statsPill">â€”</span>
  </div>

  <div class="split">

    <!-- QUIZ -->
    <div class="card quizCard" id="quizSection">
      <div class="row" style="justify-content: space-between;">
        <div class="muted" id="deckInfo">â€”</div>
        <div class="row">
          <button class="btn" id="shuffleBtn">×¢×¨×‘×•×‘ ××—×“×©</button>
          <button class="btn" id="resetProgressBtn">××™×¤×•×¡ ×”×ª×§×“××•×ª (×¨×§ ×‘×¡×©×Ÿ)</button>
        </div>
      </div>

      <div class="wordBox">
        <div class="en" id="enWord">×”×“×‘×§ ××™×œ×™× ×•××– ×”×ª×—×œ ğŸ™‚</div>
        <div class="he" id="heWord">â€”</div>
        <div class="muted" id="hintLine">×œ×—×¥ â€œ×”×¦×’ ×¤×™×¨×•×©â€, ××• â€œ×™×“×¢×ª×™ â€” ×”×‘×â€.</div>
      </div>

      <div class="row">
        <button class="btn" id="revealBtn">×”×¦×’ ×¤×™×¨×•×©</button>
        <button class="btn primary" id="knewBtn">×™×“×¢×ª×™ â€” ×”×‘×</button>
        <button class="btn" id="didntKnowBtn">×œ× ×™×“×¢×ª×™ (×œ×©××•×¨) + ×œ×”×¦×™×’</button>
      </div>

      <div class="row">
        <button class="btn ghost" id="prevBtn">×§×•×“×</button>
        <button class="btn ghost" id="nextBtn">×”×‘×</button>
        <span class="pill" id="counterPill">0/0</span>
      </div>
    </div>

    <!-- IMPORT / MANAGE -->
    <div class="card" id="importSection">
      <div class="row" style="justify-content: space-between;">
        <div>
          <div style="font-weight:800;">×”×“×‘×§×ª ××™×œ×™× (English â‡¢ Hebrew)</div>
          <div class="muted">×¤×•×¨××˜: ×‘×›×œ ×©×•×¨×” <b>×× ×’×œ×™×ª<TAB>×¢×‘×¨×™×ª</b> ××• <b>×× ×’×œ×™×ª - ×¢×‘×¨×™×ª</b> ××• <b>×× ×’×œ×™×ª,×¢×‘×¨×™×ª</b></div>
        </div>
        <div class="row">
          <button class="btn" id="loadStoredBtn">×˜×¢×Ÿ ××™×œ×™× ×©××•×¨×•×ª</button>
          <button class="btn danger" id="clearAllBtn">××—×§ ××ª ×›×œ ×”××™×œ×™×</button>
        </div>
      </div>

      <textarea id="pasteArea" placeholder="×œ×“×•×’××”:
abduct	×œ×—×˜×•×£
ability	×™×›×•×œ×ª
above	××¢×œ
..."></textarea>

      <div class="row">
        <button class="btn primary" id="importBtn">×™×™×‘×•× / ×¢×“×›×•×Ÿ ×¨×©×™××ª ××™×œ×™×</button>
        <button class="btn" id="exportBtn">×™×™×¦×•× ××™×œ×™× (JSON)</button>
        <button class="btn" id="exportUnknownBtn">×™×™×¦×•× â€œ×œ× ×™×“×¢×ª×™â€ (JSON)</button>
      </div>

      <div class="muted" id="importMsg">×˜×™×¤: ××¤×©×¨ ×œ×”×“×‘×™×§ ×›××Ÿ ×›×œ ×¤×¢× ×¢×•×“ â€œ10 ×ª××•× ×•×ªâ€ ××—×¨×™ ×©×”××¨×ª ××•×ª×Ÿ ×œ×˜×§×¡×˜.</div>
    </div>

  </div>

  <!-- LISTS -->
  <div class="card hidden" id="listSection">
    <div class="row" style="justify-content: space-between;">
      <div style="font-weight:800;" id="listTitle">â€”</div>
      <div class="row">
        <button class="btn" id="backToQuizBtn">×—×–×¨×” ×œ×ª×¨×’×•×œ</button>
        <button class="btn danger hidden" id="clearUnknownBtn">× ×§×” ××ª ×›×œ â€œ×œ× ×™×“×¢×ª×™â€</button>
      </div>
    </div>
    <div class="tableWrap">
      <table>
        <thead>
          <tr>
            <th style="width: 34%;">×× ×’×œ×™×ª</th>
            <th>×¢×‘×¨×™×ª</th>
            <th style="width: 160px;">×¡×˜×˜×•×¡</th>
            <th style="width: 170px;">×¤×¢×•×œ×•×ª</th>
          </tr>
        </thead>
        <tbody id="listBody"></tbody>
      </table>
    </div>
    <div class="muted" style="margin-top:10px;">
      ×‘×¨×©×™××ª â€œ×œ× ×™×“×¢×ª×™â€ ××¤×©×¨ ×œ×”×¡×™×¨ ××™×œ×” ××”×¨×©×™××” â€” ×•×–×” ×™×™×©××¨ ×œ×¤×¢× ×”×‘××”.
    </div>
  </div>

</div>

<script>
(() => {
  const LS_WORDS = "vocab_words_v1";
  const LS_UNKNOWN = "vocab_unknown_v1";

  /** @type {{en:string, he:string}[]} */
  let words = [];
  /** @type {Set<string>} */
  let unknown = new Set();

  // quiz state
  let mode = "all"; // "all" | "unknown"
  let deck = [];    // array of indices into words
  let pos = 0;
  let history = []; // visited positions (for prev)

  // elements
  const el = (id) => document.getElementById(id);

  const quizSection = el("quizSection");
  const importSection = el("importSection");
  const listSection = el("listSection");

  const enWord = el("enWord");
  const heWord = el("heWord");
  const counterPill = el("counterPill");
  const statsPill = el("statsPill");
  const deckInfo = el("deckInfo");

  const modeAllBtn = el("modeAllBtn");
  const modeUnknownBtn = el("modeUnknownBtn");
  const viewAllBtn = el("viewAllBtn");
  const viewUnknownBtn = el("viewUnknownBtn");

  const revealBtn = el("revealBtn");
  const knewBtn = el("knewBtn");
  const didntKnowBtn = el("didntKnowBtn");
  const nextBtn = el("nextBtn");
  const prevBtn = el("prevBtn");
  const shuffleBtn = el("shuffleBtn");
  const resetProgressBtn = el("resetProgressBtn");

  const pasteArea = el("pasteArea");
  const importBtn = el("importBtn");
  const loadStoredBtn = el("loadStoredBtn");
  const clearAllBtn = el("clearAllBtn");
  const exportBtn = el("exportBtn");
  const exportUnknownBtn = el("exportUnknownBtn");
  const importMsg = el("importMsg");

  const listTitle = el("listTitle");
  const listBody = el("listBody");
  const backToQuizBtn = el("backToQuizBtn");
  const clearUnknownBtn = el("clearUnknownBtn");

  // ---------- storage ----------
  function saveWords() {
    localStorage.setItem(LS_WORDS, JSON.stringify(words));
  }
  function saveUnknown() {
    localStorage.setItem(LS_UNKNOWN, JSON.stringify([...unknown]));
  }
  function loadFromStorage() {
    const w = localStorage.getItem(LS_WORDS);
    const u = localStorage.getItem(LS_UNKNOWN);
    words = [];
    unknown = new Set();

    if (w) {
      try {
        const parsed = JSON.parse(w);
        if (Array.isArray(parsed)) {
          words = parsed
            .filter(x => x && typeof x.en === "string" && typeof x.he === "string")
            .map(x => ({ en: x.en.trim(), he: x.he.trim() }))
            .filter(x => x.en && x.he);
        }
      } catch {}
    }
    if (u) {
      try {
        const parsedU = JSON.parse(u);
        if (Array.isArray(parsedU)) {
          parsedU.forEach(k => { if (typeof k === "string") unknown.add(k); });
        }
      } catch {}
    }
    // clean unknown keys that no longer exist
    const validKeys = new Set(words.map(w => keyOf(w)));
    unknown = new Set([...unknown].filter(k => validKeys.has(k)));
    saveUnknown();
    updateStats();
  }

  // ---------- parsing / keys ----------
  function keyOf(w) {
    return (w.en.trim().toLowerCase() + "||" + w.he.trim());
  }

  function parseLinesToWords(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    /** @type {{en:string, he:string}[]} */
    const out = [];

    for (const line of lines) {
      // try TAB first
      let en = "", he = "";
      if (line.includes("\t")) {
        [en, he] = line.split("\t");
      } else if (line.includes(" - ")) {
        [en, he] = line.split(" - ");
      } else if (line.includes(" â€“ ")) {
        [en, he] = line.split(" â€“ ");
      } else if (line.includes(",")) {
        // CSV-ish
        const parts = line.split(",");
        en = parts[0];
        he = parts.slice(1).join(","); // allow commas in Hebrew part
      } else if (line.includes("â€”")) {
        [en, he] = line.split("â€”");
      } else if (line.includes("-")) {
        // fallback (careful: words like "co-operate" exist, but user said they'll paste clean text)
        const idx = line.indexOf("-");
        en = line.slice(0, idx);
        he = line.slice(idx + 1);
      } else {
        continue; // cannot parse
      }

      en = (en || "").trim();
      he = (he || "").trim();
      if (!en || !he) continue;
      out.push({ en, he });
    }

    // de-dup by key
    const seen = new Set();
    const dedup = [];
    for (const w of out) {
      const k = keyOf(w);
      if (seen.has(k)) continue;
      seen.add(k);
      dedup.push(w);
    }
    return dedup;
  }

  // ---------- deck / quiz ----------
  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  function buildDeck(newMode) {
    mode = newMode;

    const allIdx = words.map((_, i) => i);
    if (mode === "unknown") {
      const idx = allIdx.filter(i => unknown.has(keyOf(words[i])));
      deck = shuffle(idx);
    } else {
      deck = shuffle(allIdx);
    }
    pos = 0;
    history = [];
    renderCard();
    updateStats();
    updateModeButtons();
  }

  function updateModeButtons() {
    modeAllBtn.classList.toggle("primary", mode === "all");
    modeUnknownBtn.classList.toggle("primary", mode === "unknown");
  }

  function currentWord() {
    if (!deck.length) return null;
    const idx = deck[pos];
    return words[idx] || null;
  }

  function renderCard() {
    const total = deck.length;

    if (!words.length) {
      enWord.textContent = "×¢×“×™×™×Ÿ ××™×Ÿ ××™×œ×™×. ×”×“×‘×§ ×˜×§×¡×˜ ×‘×¦×“ ×™××™×Ÿ ×•×œ×—×¥ ×™×™×‘×•×.";
      heWord.textContent = "";
      heWord.classList.remove("show");
      counterPill.textContent = "0/0";
      deckInfo.textContent = "××™×Ÿ ×—×¤×™×¡×” ×œ×ª×¨×’×•×œ";
      return;
    }

    if (!total) {
      enWord.textContent = (mode === "unknown")
        ? "××™×Ÿ ××™×œ×™× ×‘â€œ×œ× ×™×“×¢×ª×™â€ ğŸ‰"
        : "××™×Ÿ ××™×œ×™× ×œ×ª×¨×’×•×œ";
      heWord.textContent = "";
      heWord.classList.remove("show");
      counterPill.textContent = "0/0";
      deckInfo.textContent = (mode === "unknown")
        ? "××¦×‘: ×¨×§ ×œ× ×™×“×¢×ª×™"
        : "××¦×‘: ×›×œ ×”××™×œ×™×";
      return;
    }

    if (pos < 0) pos = 0;
    if (pos >= total) pos = total - 1;

    const w = currentWord();
    if (!w) return;

    enWord.textContent = w.en;
    heWord.textContent = w.he;
    heWord.classList.remove("show");

    counterPill.textContent = `${pos + 1}/${total}`;
    deckInfo.textContent = `××¦×‘: ${mode === "unknown" ? "×¨×§ ×œ× ×™×“×¢×ª×™" : "×›×œ ×”××™×œ×™×"} Â· ×¢×¨×‘×•×‘ ×‘×›×œ ×¤×ª×™×—×”/×¢×¨×‘×•×‘`;
  }

  function goNext(pushHistory = true) {
    if (!deck.length) return;
    if (pushHistory) history.push(pos);
    pos = (pos + 1) % deck.length;
    renderCard();
  }

  function goPrev() {
    if (!deck.length) return;
    if (history.length) pos = history.pop();
    else pos = (pos - 1 + deck.length) % deck.length;
    renderCard();
  }

  function reveal() {
    heWord.classList.add("show");
  }

  function markUnknownAndReveal() {
    const w = currentWord();
    if (!w) return;
    unknown.add(keyOf(w));
    saveUnknown();
    reveal();
    updateStats();
  }

  function unmarkUnknownByKey(k) {
    unknown.delete(k);
    saveUnknown();
    updateStats();
  }

  // ---------- lists ----------
  function showList(which) {
    // which: "all" | "unknown"
    quizSection.classList.add("hidden");
    importSection.classList.add("hidden");
    listSection.classList.remove("hidden");

    const rows = [];
    if (which === "unknown") {
      clearUnknownBtn.classList.remove("hidden");
      listTitle.textContent = "×¨×©×™××ª ××™×œ×™× ×©×¡×™×× ×ª×™ â€œ×œ× ×™×“×¢×ª×™â€";
      for (const w of words) {
        const k = keyOf(w);
        if (unknown.has(k)) rows.push({ w, k, status: "×œ× ×™×“×¢×ª×™" });
      }
    } else {
      clearUnknownBtn.classList.add("hidden");
      listTitle.textContent = "×¨×©×™××ª ×›×œ ×”××™×œ×™×";
      for (const w of words) {
        const k = keyOf(w);
        rows.push({ w, k, status: unknown.has(k) ? "×œ× ×™×“×¢×ª×™" : "×™×•×“×¢" });
      }
    }

    listBody.innerHTML = rows.map(({w,k,status}) => {
      const isBad = status === "×œ× ×™×“×¢×ª×™";
      const tagClass = isBad ? "tag bad" : "tag ok";
      const actionBtn = isBad
        ? `<button class="btn" data-action="remove-unknown" data-key="${escapeHtmlAttr(k)}">×”×¡×¨ ×â€œ×œ× ×™×“×¢×ª×™â€</button>`
        : `<button class="btn ghost" disabled>â€”</button>`;
      return `
        <tr>
          <td class="enCell">${escapeHtml(w.en)}</td>
          <td class="heCell">${escapeHtml(w.he)}</td>
          <td><span class="${tagClass}">${escapeHtml(status)}</span></td>
          <td>${actionBtn}</td>
        </tr>
      `;
    }).join("");

    listBody.querySelectorAll("button[data-action='remove-unknown']").forEach(btn => {
      btn.addEventListener("click", () => {
        const k = btn.getAttribute("data-key");
        if (!k) return;
        unmarkUnknownByKey(unescapeHtmlAttr(k));
        // refresh list
        showList(which);
      });
    });
  }

  function backToQuiz() {
    listSection.classList.add("hidden");
    quizSection.classList.remove("hidden");
    importSection.classList.remove("hidden");
    renderCard();
  }

  // ---------- export ----------
  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "application/json;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // ---------- UI stats ----------
  function updateStats() {
    const total = words.length;
    const unkCount = [...unknown].length;
    statsPill.textContent = `×¡×”"×›: ${total} Â· ×œ× ×™×“×¢×ª×™: ${unkCount}`;
    modeUnknownBtn.disabled = (unkCount === 0);
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  // attributes: keep simple
  function escapeHtmlAttr(s){ return escapeHtml(s).replaceAll("||","&#124;&#124;"); }
  function unescapeHtmlAttr(s){ return s.replaceAll("&#124;&#124;","||"); }

  // ---------- actions ----------
  modeAllBtn.addEventListener("click", () => buildDeck("all"));
  modeUnknownBtn.addEventListener("click", () => buildDeck("unknown"));
  viewAllBtn.addEventListener("click", () => showList("all"));
  viewUnknownBtn.addEventListener("click", () => showList("unknown"));

  revealBtn.addEventListener("click", reveal);
  knewBtn.addEventListener("click", () => goNext(true));
  didntKnowBtn.addEventListener("click", () => {
    markUnknownAndReveal();
    // ×œ× ××¢×‘×™×¨×™× ××•×˜×•××˜×™×ª ×›×“×™ ×©×ª×•×›×œ ×œ×¨××•×ª ××ª ×”×¤×™×¨×•×©
  });

  nextBtn.addEventListener("click", () => goNext(true));
  prevBtn.addEventListener("click", () => goPrev());

  shuffleBtn.addEventListener("click", () => buildDeck(mode));
  resetProgressBtn.addEventListener("click", () => { pos = 0; history = []; renderCard(); });

  importBtn.addEventListener("click", () => {
    const text = pasteArea.value || "";
    const imported = parseLinesToWords(text);

    if (!imported.length) {
      importMsg.textContent = "×œ× ×–×™×”×™×ª×™ ××™×œ×™×. ×‘×“×•×§ ×¤×•×¨××˜: ×× ×’×œ×™×ª<TAB>×¢×‘×¨×™×ª ××• ×× ×’×œ×™×ª - ×¢×‘×¨×™×ª.";
      return;
    }

    // merge with existing
    const map = new Map(words.map(w => [keyOf(w), w]));
    for (const w of imported) map.set(keyOf(w), w);
    words = [...map.values()];

    // clean unknown to only valid keys
    const validKeys = new Set(words.map(w => keyOf(w)));
    unknown = new Set([...unknown].filter(k => validKeys.has(k)));

    saveWords();
    saveUnknown();

    importMsg.textContent = `×™×™×‘×•× ×”×¦×œ×™×—: × ×•×¡×¤×•/×¢×•×“×›× ×• ${imported.length} ×©×•×¨×•×ª. ×¡×”"×› ×‘×××’×¨: ${words.length}.`;
    buildDeck(mode); // rebuild with shuffle
  });

  loadStoredBtn.addEventListener("click", () => {
    loadFromStorage();
    buildDeck(mode);
    importMsg.textContent = `× ×˜×¢× ×• ××™×œ×™× ××”×“×¤×“×¤×Ÿ. ×¡×”"×›: ${words.length}.`;
  });

  clearAllBtn.addEventListener("click", () => {
    if (!confirm("×œ××—×•×§ ××ª ×›×œ ×”××™×œ×™× + ×¨×©×™××ª '×œ× ×™×“×¢×ª×™' ××”×“×¤×“×¤×Ÿ?")) return;
    localStorage.removeItem(LS_WORDS);
    localStorage.removeItem(LS_UNKNOWN);
    words = [];
    unknown = new Set();
    pasteArea.value = "";
    buildDeck("all");
    importMsg.textContent = "× ××—×§ ×”×›×œ. ××¤×©×¨ ×œ×”×“×‘×™×§ ××—×“×©.";
  });

  exportBtn.addEventListener("click", () => {
    downloadText("words.json", JSON.stringify(words, null, 2));
  });

  exportUnknownBtn.addEventListener("click", () => {
    const unkWords = words.filter(w => unknown.has(keyOf(w)));
    downloadText("unknown_words.json", JSON.stringify(unkWords, null, 2));
  });

  backToQuizBtn.addEventListener("click", backToQuiz);

  clearUnknownBtn.addEventListener("click", () => {
    if (!confirm("×œ× ×§×•×ª ××ª ×›×œ ×¨×©×™××ª '×œ× ×™×“×¢×ª×™'?")) return;
    unknown = new Set();
    saveUnknown();
    updateStats();
    showList("unknown");
  });

  // keyboard shortcuts
  document.addEventListener("keydown", (e) => {
    // ignore when typing in textarea
    if (document.activeElement && document.activeElement.tagName === "TEXTAREA") return;

    if (e.key === " "){ e.preventDefault(); reveal(); }
    if (e.key === "ArrowRight"){ e.preventDefault(); goNext(true); }
    if (e.key === "ArrowLeft"){ e.preventDefault(); goPrev(); }
    if (e.key.toLowerCase() === "x"){ e.preventDefault(); markUnknownAndReveal(); }
  });

  // init
  loadFromStorage();
  buildDeck("all");
})();
</script>
</body>
</html>
