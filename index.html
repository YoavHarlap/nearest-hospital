<!DOCTYPE html>
<html lang="he">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vocabulary Trainer</title>

<style>
  body {
    margin: 0;
    background: #f2f2f2;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }

  .app {
    width: 100%;
    max-width: 420px;
    background: #ffffff;
    padding: 24px;
    box-sizing: border-box;
    text-align: center;
  }

  .status {
    font-size: 14px;
    color: #555;
    margin-bottom: 10px;
  }

  .word {
    font-size: 40px;
    font-weight: 700;
    margin: 24px 0;
  }

  .meaning {
    font-size: 22px;
    color: #333;
    min-height: 34px;
    margin-bottom: 20px;
  }

  button {
    width: 100%;
    padding: 16px;
    margin: 6px 0;
    font-size: 17px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
  }

  .show { background: #e0e0e0; }
  .know { background: #4CAF50; color: white; }
  .dont { background: #f44336; color: white; }
  .mode { background: #2196F3; color: white; }
  .reset { background: #9e9e9e; color: white; }
</style>
</head>

<body>
<div class="app">

  <div class="status" id="status"></div>

  <div class="word" id="word"></div>
  <div class="meaning" id="meaning"></div>

  <button class="show" onclick="showMeaning()">×”×¦×’ ×¤×™×¨×•×©</button>

  <button class="know" onclick="markKnown()">×™×“×¢×ª×™</button>
  <button class="dont" onclick="markUnknown()">×œ× ×™×“×¢×ª×™</button>

  <button class="mode" onclick="switchMode()" id="modeBtn"></button>
  <button class="reset" onclick="resetLists()">××™×¤×•×¡ ×›×œ ×”×¨×©×™××•×ª</button>

</div>

<script>
/* ========= ×××’×¨ ××™×œ×™× ========= */
const WORDS = [
  { en: "pledge", he: "×œ×”×ª×—×™×™×‘; ×”×‘×˜×—×”" },
  { en: "plot", he: "×¢×œ×™×œ×”; ××–×™××”" },
  { en: "poem", he: "×©×™×¨" },
  { en: "power", he: "×›×•×—" },
  { en: "progress", he: "×”×ª×§×“××•×ª" },
  { en: "trust", he: "×××•×Ÿ" },
  { en: "vulnerable", he: "×¤×’×™×¢" },
  { en: "zone", he: "××–×•×¨" }
  // â¬† ×›××Ÿ ×™×”×™×• ×‘×¤×•×¢×œ ×›×œ 2,229 ×”××™×œ×™×
];

/* ========= ××—×¡×•×Ÿ ========= */
const LS = {
  seen: "seenWords",
  known: "knownWords",
  unknown: "unknownWords"
};

function getSet(key) {
  return new Set(JSON.parse(localStorage.getItem(key) || "[]"));
}
function saveSet(key, set) {
  localStorage.setItem(key, JSON.stringify([...set]));
}

/* ========= ××¦×‘×™× ========= */
let mode = "unseen"; // unseen | known | unknown
let currentWord = null;

/* ========= ×¨×©×™××” ×¤×¢×™×œ×” ========= */
function activeList() {
  const seen = getSet(LS.seen);
  const known = getSet(LS.known);
  const unknown = getSet(LS.unknown);

  if (mode === "unseen") {
    return WORDS.filter(w => !seen.has(w.en));
  }
  if (mode === "known") {
    return WORDS.filter(w => known.has(w.en));
  }
  return WORDS.filter(w => unknown.has(w.en));
}

/* ========= ×˜×¢×™× ×ª ××™×œ×” ========= */
function loadWord() {
  const list = activeList();

  if (list.length === 0) {
    document.getElementById("word").textContent = "ğŸ‰ ×¡×™×™××ª ××ª ×›×œ ×”×›×¨×˜×™×¡×™×•×ª!";
    document.getElementById("meaning").textContent = "";
    return;
  }

  currentWord = list[Math.floor(Math.random() * list.length)];
  document.getElementById("word").textContent = currentWord.en;
  document.getElementById("meaning").textContent = "";
  updateStatus();
}

function showMeaning() {
  if (currentWord)
    document.getElementById("meaning").textContent = currentWord.he;
}

/* ========= ×›×¤×ª×•×¨×™× ========= */

// ×™×“×¢×ª×™
function markKnown() {
  if (!currentWord) return;

  const seen = getSet(LS.seen);
  const known = getSet(LS.known);
  const unknown = getSet(LS.unknown);

  showMeaning();

  seen.add(currentWord.en);
  known.add(currentWord.en);
  unknown.delete(currentWord.en);

  saveSet(LS.seen, seen);
  saveSet(LS.known, known);
  saveSet(LS.unknown, unknown);

  setTimeout(loadWord, 500);
}

// ×œ× ×™×“×¢×ª×™
function markUnknown() {
  if (!currentWord) return;

  const seen = getSet(LS.seen);
  const known = getSet(LS.known);
  const unknown = getSet(LS.unknown);

  showMeaning();

  seen.add(currentWord.en);
  unknown.add(currentWord.en);
  known.delete(currentWord.en);

  saveSet(LS.seen, seen);
  saveSet(LS.known, known);
  saveSet(LS.unknown, unknown);

  setTimeout(loadWord, 500);
}

/* ========= ××¦×‘×™× ========= */
function switchMode() {
  mode =
    mode === "unseen" ? "unknown" :
    mode === "unknown" ? "known" :
    "unseen";

  loadWord();
}

/* ========= ××™×¤×•×¡ ========= */
function resetLists() {
  if (!confirm("×œ××¤×¡ ××ª ×›×œ ×”×¨×©×™××•×ª?")) return;
  localStorage.removeItem(LS.seen);
  localStorage.removeItem(LS.known);
  localStorage.removeItem(LS.unknown);
  mode = "unseen";
  loadWord();
}

/* ========= ×¡×˜×˜×•×¡ ========= */
function updateStatus() {
  const seen = getSet(LS.seen).size;
  const known = getSet(LS.known).size;
  const unknown = getSet(LS.unknown).size;

  document.getElementById("status").textContent =
    `××¦×‘: ${
      mode === "unseen" ? "×œ× × ×¦×¤×•" :
      mode === "known" ? "×™×“×¢×ª×™" :
      "×œ× ×™×“×¢×ª×™"
    } | ×œ× × ×¦×¤×•: ${WORDS.length - seen} | ×™×“×¢×ª×™: ${known} | ×œ× ×™×“×¢×ª×™: ${unknown}`;

  document.getElementById("modeBtn").textContent =
    mode === "unseen"
      ? "×¢×‘×•×¨ ×œ×¨×©×™××ª ×”×œ× ×™×“×¢×ª×™"
      : mode === "unknown"
      ? "×¢×‘×•×¨ ×œ×¨×©×™××ª ×”×™×“×¢×ª×™"
      : "×¢×‘×•×¨ ×œ×¨×©×™××ª ×”×œ× × ×¦×¤×•";
}

/* ========= ×”×ª×—×œ×” ========= */
loadWord();
</script>

</body>
</html>
